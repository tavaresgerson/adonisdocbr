import{_ as o,c as a,a2 as s,o as i}from"./chunks/framework.BLTIpkzl.js";const m=JSON.parse('{"title":"Processo de construção do TypeScript","description":"","frontmatter":{},"headers":[],"relativePath":"docs/guides/fundamentals/typescript-build-process.md","filePath":"docs/guides/fundamentals/typescript-build-process.md"}'),r={name:"docs/guides/fundamentals/typescript-build-process.md"};function d(t,e,n,c,p,l){return i(),a("div",null,e[0]||(e[0]=[s(`<h1 id="processo-de-construcao-do-typescript" tabindex="-1">Processo de construção do TypeScript <a class="header-anchor" href="#processo-de-construcao-do-typescript" aria-label="Permalink to &quot;Processo de construção do TypeScript&quot;">​</a></h1><p>Um dos objetivos do framework é fornecer suporte de primeira classe para o TypeScript. Isso vai além dos tipos estáticos e do IntelliSense que você pode aproveitar ao escrever o código.</p><p><strong>Também garantimos que você nunca precise instalar nenhuma ferramenta de construção adicional para compilar seu código durante o desenvolvimento ou para produção.</strong></p><div class="info custom-block"><p class="custom-block-title">NOTA</p><p>Este guia pressupõe que você tenha algum conhecimento sobre o TypeScript e o ecossistema de ferramentas de construção.</p></div><h2 id="abordagens-comuns-de-agrupamento" tabindex="-1">Abordagens comuns de agrupamento <a class="header-anchor" href="#abordagens-comuns-de-agrupamento" aria-label="Permalink to &quot;Abordagens comuns de agrupamento&quot;">​</a></h2><p>A seguir estão algumas das abordagens comuns para desenvolver um aplicativo Node.js escrito em TypeScript.</p><h3 id="usando-tsc" tabindex="-1">Usando tsc <a class="header-anchor" href="#usando-tsc" aria-label="Permalink to &quot;Usando tsc&quot;">​</a></h3><p>A maneira mais simples de compilar seu código TypeScript para JavaScript é usando a linha de comando oficial <code>tsc</code>.</p><ul><li>Durante o desenvolvimento, você pode compilar seu código no modo de observação usando o comando <code>tsc --watch</code>.</li><li>Em seguida, você pode pegar <code>nodemon</code> para observar a saída compilada (código JavaScript) e reiniciar o servidor HTTP em cada alteração. Neste momento, você tem dois observadores em execução. <a href="https://github.com/microsoft/TypeScript/issues/30835" target="_blank" rel="noreferrer">scripts personalizados para copiar arquivos estáticos</a> como <strong>templates</strong> para a pasta de compilação para que seu código JavaScript de tempo de execução possa encontrá-lo e referenciá-lo.</li></ul><h3 id="usando-ts-node" tabindex="-1">Usando ts-node <a class="header-anchor" href="#usando-ts-node" aria-label="Permalink to &quot;Usando ts-node&quot;">​</a></h3><p>ts-node melhora a experiência de desenvolvimento, pois compila o código na memória e não o envia para o disco. Assim, você pode combinar <code>ts-node</code> e <code>nodemon</code> e executar seu código TypeScript como um cidadão de primeira classe.</p><p>No entanto, para aplicativos maiores, <code>ts-node</code> pode ficar lento, pois precisa recompilar o projeto inteiro em cada alteração de arquivo. Em contraste, <code>tsc</code> estava reconstruindo apenas o arquivo alterado.</p><p>Observe que <code>ts-node</code> é uma ferramenta somente para desenvolvimento. Portanto, você ainda precisa compilar seu código para JavaScript usando <code>tsc</code> e escrever scripts personalizados para copiar arquivos estáticos para produção.</p><h3 id="usando-webpack" tabindex="-1">Usando Webpack <a class="header-anchor" href="#usando-webpack" aria-label="Permalink to &quot;Usando Webpack&quot;">​</a></h3><p>Depois de tentar as abordagens acima, você pode decidir experimentar o Webpack. O Webpack é uma ferramenta de construção e tem muito a oferecer. Mas, ele vem com seu próprio conjunto de desvantagens.</p><ul><li>Primeiro, usar o Webpack para agrupar o código de backend é um exagero. Você pode nem precisar de 90% dos recursos do Webpack criados para atender ao ecossistema de frontend.</li><li>Você pode ter que repetir algumas das configurações no arquivo <code>webpack.config.js</code> config e <code>tsconfig.json</code> principalmente, quais arquivos observar e ignorar. <a href="https://stackoverflow.com/questions/40096470/get-webpack-not-to-bundle-files" target="_blank" rel="noreferrer">Webpack NÃO agrupar</a> todo o backend em um único arquivo.</li></ul><h2 id="abordagem-adonisjs" tabindex="-1">Abordagem AdonisJS <a class="header-anchor" href="#abordagem-adonisjs" aria-label="Permalink to &quot;Abordagem AdonisJS&quot;">​</a></h2><p>Não somos grandes fãs de ferramentas de construção muito complicadas e compiladores de ponta. Ter uma experiência de desenvolvimento tranquila é muito mais valioso do que expor a configuração para ajustar cada botão.</p><p>Começamos com o seguinte conjunto de objetivos.</p><ul><li>Use o compilador oficial do TypeScript e não use nenhuma outra ferramenta como <code>esbuild</code> ou <code>swc</code>. Elas são ótimas alternativas, mas não suportam alguns dos recursos do TypeScript (ex. <a href="https://levelup.gitconnected.com/writing-typescript-custom-ast-transformer-part-1-7585d6916819" target="_blank" rel="noreferrer">a API Transformers</a>).</li><li>O arquivo <code>tsconfig.json</code> existente deve gerenciar todas as configurações.</li><li>Se o código roda em desenvolvimento, ele também deve rodar em produção. Ou seja, não use duas ferramentas de desenvolvimento e produção completamente diferentes e depois ensine as pessoas a ajustarem seus códigos.</li><li>Adicione suporte leve para copiar arquivos estáticos para a pasta de build final. Normalmente, esses serão os modelos do Edge.</li><li><strong>Certifique-se de que o REPL também pode executar o código TypeScript como um cidadão de primeira classe. Todas as abordagens acima, exceto <code>ts-node</code>, não podem compilar e avaliar o código TypeScript diretamente.</strong></li></ul><h2 id="compilador-de-desenvolvimento-na-memoria" tabindex="-1">Compilador de desenvolvimento na memória <a class="header-anchor" href="#compilador-de-desenvolvimento-na-memoria" aria-label="Permalink to &quot;Compilador de desenvolvimento na memória&quot;">​</a></h2><p>Semelhante ao ts-node, criamos o módulo <a href="https://github.com/adonisjs/require-ts" target="_blank" rel="noreferrer">@adonisjs/require-ts</a>. Ele usa a API do compilador TypeScript, o que significa que todos os recursos do TypeScript funcionam, e seu arquivo <code>tsconfig.json</code> é a única fonte da verdade.</p><p>No entanto, <code>@adonisjs/require-ts</code> é ligeiramente diferente de <code>ts-node</code> nas seguintes maneiras.</p><ul><li>Não realizamos nenhuma verificação de tipo durante o desenvolvimento e esperamos que você confie no seu editor de código para o mesmo.</li><li>Armazenamos a <a href="https://github.com/adonisjs/require-ts/blob/develop/src/Compiler/index.ts#L185-L223" target="_blank" rel="noreferrer">saída compilada</a> em uma pasta de cache. Então, na próxima vez que seu servidor reiniciar, não recompilaremos os arquivos inalterados. Isso melhora a velocidade drasticamente.</li><li>Os arquivos em cache precisam ser excluídos em algum momento. O módulo <code>@adonisjs/require-ts</code> expõe os <a href="https://github.com/adonisjs/require-ts/blob/develop/index.ts#L43-L57" target="_blank" rel="noreferrer">métodos auxiliares</a> que o observador de arquivos do AdonisJS usa para limpar o cache do arquivo alterado recentemente.</li><li>Limpar o cache é essencial apenas para reivindicar o espaço em disco. Não afeta o comportamento do programa.</li></ul><p>Toda vez que você executa <code>node ace serve --watch</code>, iniciamos o servidor HTTP junto com o compilador na memória e observamos o sistema de arquivos para alterações de arquivo.</p><h2 id="builds-de-producao-autonomos" tabindex="-1">Builds de produção autônomos <a class="header-anchor" href="#builds-de-producao-autonomos" aria-label="Permalink to &quot;Builds de produção autônomos&quot;">​</a></h2><p>Você cria seu código para produção executando o comando <code>node ace build --production</code>. Ele executa as seguintes operações.</p><ul><li>Limpe o diretório <code>build</code> existente (se houver).</li><li>Crie seus ativos de frontend usando o Webpack Encore (somente se estiver instalado).</li><li>Use a API do compilador TypeScript para compilar o código TypeScript para JavaScript e escrevê-lo dentro da pasta <code>build</code>. <strong>Desta vez, realizamos a verificação de tipo e relatamos os erros do TypeScript</strong>.</li><li>Copie todos os arquivos estáticos para a pasta <code>build</code>. Os arquivos estáticos são registrados dentro do arquivo <code>.adonisrc.json</code> sob o array <code>metaFiles</code>.</li><li>Copie <code>package.json</code> e <code>package-lock.json</code>/<code>yarn.lock</code> para a pasta <code>build</code>.</li><li>Gere o arquivo <code>ace-manifest.json</code>. Ele contém um índice de todos os comandos que seu projeto está usando.</li><li>Isso é tudo.</li></ul><h4 id="por-que-chamamos-isso-de-build-autonomo" tabindex="-1">Por que chamamos isso de build autônomo? <a class="header-anchor" href="#por-que-chamamos-isso-de-build-autonomo" aria-label="Permalink to &quot;Por que chamamos isso de build autônomo?&quot;">​</a></h4><p>Depois de executar o comando <code>build</code>, a pasta de saída tem tudo o que você precisa para implantar seu aplicativo em produção.</p><p>Você pode copiar a pasta <code>build</code> sem seu código-fonte TypeScript, e seu aplicativo funcionará perfeitamente.</p><p>Criar uma pasta <code>build</code> autônoma ajuda a reduzir o tamanho do código que você implanta em seu servidor de produção. Isso geralmente é útil quando você empacota seu aplicativo como uma imagem Docker. No entanto, não há necessidade de ter a saída de origem e build em sua imagem Docker e mantê-la leve.</p><h4 id="pontos-a-serem-lembrados" tabindex="-1">Pontos a serem lembrados <a class="header-anchor" href="#pontos-a-serem-lembrados" aria-label="Permalink to &quot;Pontos a serem lembrados&quot;">​</a></h4><ul><li>Após a compilação, a pasta de saída se torna a raiz do seu aplicativo JavaScript.</li><li>Você deve sempre <code>cd</code> na pasta <code>build</code> e então executar seu aplicativo.<div class="language-sh vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cd</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> build</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">node</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> server.js</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li><li>Você deve instalar dependências somente de produção dentro da pasta <code>build</code>.<div class="language-sh vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cd</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> build</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ci</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --production</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li><li>Não copiamos o arquivo <code>.env</code> para a pasta de saída. Como as variáveis ​​de ambiente não são transferíveis, você deve definir variáveis ​​de ambiente para produção separadamente.</li></ul>`,34)]))}const v=o(r,[["render",d]]);export{m as __pageData,v as default};
