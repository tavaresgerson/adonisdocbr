import{_ as o,c as e,o as a,a4 as i}from"./chunks/framework.nQaBHiNx.js";const v=JSON.parse('{"title":"Ciclo de vida do aplicativo","description":"","frontmatter":{},"headers":[],"relativePath":"docs/02-core-concepts/04-application-lifecycle.md","filePath":"docs/02-core-concepts/04-application-lifecycle.md"}'),s={name:"docs/02-core-concepts/04-application-lifecycle.md"},t=i(`<h1 id="ciclo-de-vida-do-aplicativo" tabindex="-1">Ciclo de vida do aplicativo <a class="header-anchor" href="#ciclo-de-vida-do-aplicativo" aria-label="Permalink to &quot;Ciclo de vida do aplicativo&quot;">​</a></h1><p>O guia é voltado para dar a você uma compreensão profunda do fluxo do aplicativo AdonisJs. O fluxo é dividido em três categorias amplas de <em>Servidor HTTP</em>, <em>Comando Ace</em> e <em>Solicitação HTTP</em>.</p><h2 id="servidor-http" tabindex="-1">Servidor HTTP <a class="header-anchor" href="#servidor-http" aria-label="Permalink to &quot;Servidor HTTP&quot;">​</a></h2><p>O servidor HTTP envolve conectar as partes do aplicativo e inicializar o servidor HTTP. Este é um trabalho único, pois o servidor HTTP é um processo de longa execução.</p><p>O primeiro passo é carregar todos os provedores e configurar seus aliases. Vamos falar sobre todas as etapas envolvidas:</p><ol><li>Os provedores e seus aliases são definidos dentro do arquivo <code>bootstrap/app.js</code>.</li><li>O arquivo <code>bootstrap/http.js</code> fará uso do array <code>providers</code> e os registrará com o contêiner IoC.</li><li>Em seguida, registramos o diretório de carregamento automático definido dentro do arquivo <code>package.json</code>. Você pode alterar o diretório ou o namespace de carregamento automático que está definido como <code>App</code>.<div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;autoload&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;App&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./app&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li>O processo de inicialização carregará os seguintes arquivos na sequência definida. <ul><li><code>bootstrap/events.js</code></li><li><code>app/Http/kernel.js</code></li><li><code>app/Http/routes.js</code></li><li><code>database/factory.js</code></li></ul></li><li>Finalmente, ele iniciará o servidor HTTP escutando no host e na porta definidos dentro do arquivo <code>.env</code> e emitirá o evento <code>Http.start</code>, que você pode escutar para conectar suas implementações personalizadas.</li></ol><h2 id="comando-ace" tabindex="-1">Comando Ace <a class="header-anchor" href="#comando-ace" aria-label="Permalink to &quot;Comando Ace&quot;">​</a></h2><p>O processo de conexão do comando ace é semelhante ao <a href="#servidor-http">Http Server</a>, mas seguindo as diferenças.</p><ol><li>Todos os provedores definidos dentro do arquivo <code>bootstrap/app.js</code> serão carregados. O que significa que <code>aceProviders</code> e <code>providers</code> serão concatenados e enviados ao contêiner IoC.</li><li>Todos os arrays <code>commands</code> serão registrados com <a href="/docs/07-common-web-tools/01-interactive-shell.html">Ace</a>.</li><li>Desta vez, o evento <code>Ace.start</code> é emitido em vez de <code>Http.start</code>.</li></ol><h2 id="solicitacao-http" tabindex="-1">Solicitação HTTP <a class="header-anchor" href="#solicitacao-http" aria-label="Permalink to &quot;Solicitação HTTP&quot;">​</a></h2><p>A solicitação HTTP é um fluxo dinâmico de processamento de uma ou mais solicitações HTTP em um determinado momento.</p><ol><li>A URL da solicitação de entrada é verificada em relação a um arquivo estático dentro do diretório <code>public</code> e, se encontrado, o arquivo estático será servido.</li><li>Em seguida, uma rota correspondente será pesquisada em relação à URL da solicitação e as seguintes etapas serão executadas. <ul><li>Executar todos os middlewares globais</li><li>Executar todos os middlewares específicos da rota</li><li>Executar a ação da rota que pode ser um <em>Método do controlador</em> ou um <em>Closure</em>.</li></ul></li><li>Se acima de 2 forem falsos, uma <code>HttpException</code> 404 será lançada.</li></ol>`,12),d=[t];function r(c,l,n,p,u,m){return a(),e("div",null,d)}const f=o(s,[["render",r]]);export{v as __pageData,f as default};
