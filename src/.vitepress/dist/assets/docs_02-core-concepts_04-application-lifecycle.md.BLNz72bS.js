import{_ as e,c as o,o as a,a4 as i}from"./chunks/framework.nQaBHiNx.js";const v=JSON.parse('{"title":"Ciclo de Vida da Aplicação","description":"","frontmatter":{},"headers":[],"relativePath":"docs/02-core-concepts/04-application-lifecycle.md","filePath":"docs/02-core-concepts/04-application-lifecycle.md"}'),s={name:"docs/02-core-concepts/04-application-lifecycle.md"},t=i(`<h1 id="ciclo-de-vida-da-aplicacao" tabindex="-1">Ciclo de Vida da Aplicação <a class="header-anchor" href="#ciclo-de-vida-da-aplicacao" aria-label="Permalink to &quot;Ciclo de Vida da Aplicação&quot;">​</a></h1><p>O guia é direcionado para dar a você uma compreensão profunda do fluxo de aplicativos AdonisJS. O fluxo é dividido em três categorias amplas de <em>Servidor HTTP</em>, <em>Comando Ace</em> e <em>Solicitação HTTP</em>.</p><h2 id="servidor-http" tabindex="-1">Servidor HTTP <a class="header-anchor" href="#servidor-http" aria-label="Permalink to &quot;Servidor HTTP&quot;">​</a></h2><p>O servidor HTTP envolve a conexão das peças do aplicativo e o arranque do servidor HTTP. Isso é um trabalho único, já que o servidor HTTP é um processo de longa execução.</p><p>A primeira etapa é carregar todos os provedores e configurar seus aliases. Vamos falar sobre todas as etapas envolvidas:</p><ol><li>Provedores e seus aliases são definidos no arquivo <code>bootstrap/app.js</code>.</li><li>O arquivo <code>bootstrap/http.js</code> fará uso do array <code>providers</code> e registrará-os no contêiner IoC. Em seguida, registramos o diretório de carregamento automático definido dentro do arquivo <code>package.json</code>. Você é livre para alterar o diretório ou o namespace de carregamento automático que está definido como <code>App</code>.</li></ol><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;autoload&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;App&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./app&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ol><li>O processo de inicialização então carregará os seguintes arquivos na sequência definida.</li></ol><ul><li>bootstrap/events.js app/Http/kernel.js app/Http/routes.js database/factory.js</li></ul><ol start="2"><li>Finalmente, ele iniciará o servidor HTTP escutando na porta e no host definidos dentro do arquivo .env e emite o evento &#39;Http.start&#39;, que você pode ouvir para implementar suas próprias personalizações.</li></ol><h2 id="ace-comando" tabindex="-1">Ace Comando <a class="header-anchor" href="#ace-comando" aria-label="Permalink to &quot;Ace Comando&quot;">​</a></h2><p>O processo de ligação do comando ace é semelhante ao xref:[Http Server] mas com as seguintes diferenças.</p><ol><li>Todos os Provedores definidos dentro do arquivo <code>bootstrap/app.js</code> serão carregados. O que significa que <code>aceProviders</code> e <code>providers</code> serão concatenados e enviados para o contêiner IoC.</li><li>Todos os comandos do array serão registrados com o link: shell interativo [Ace].</li><li>Neste caso o evento &#39;Ace.start&#39; é emitido em vez de &#39;Http.start&#39;.</li></ol><h2 id="http-request" tabindex="-1">HTTP Request <a class="header-anchor" href="#http-request" aria-label="Permalink to &quot;HTTP Request&quot;">​</a></h2><p>A solicitação HTTP é um fluxo dinâmico de processamento de uma ou mais solicitações HTTP em um determinado momento.</p><ol><li>A URL da solicitação de entrada é verificada contra um arquivo estático dentro do diretório &quot;público&quot; e se encontrado o arquivo estático será servido.</li><li>Em seguida, uma rota correspondente será pesquisada contra a URL da solicitação e as seguintes etapas serão executadas.</li></ol><ul><li>Executar todos os middlewares globais</li><li>Executar todo o middleware específico de rota</li><li>Executar ação de rota que pode ser um <em>método do controlador</em> ou um <em>fechamento</em>.</li></ul><ol start="3"><li>Se os dois acima forem falsos, será lançada uma exceção de código 404 HttpException.</li></ol>`,18),r=[t];function d(c,l,n,p,u,m){return a(),o("div",null,r)}const f=e(s,[["render",d]]);export{v as __pageData,f as default};
