import{_ as a,c as o,a2 as s,o as r}from"./chunks/framework.Dz7_3PEu.js";const p=JSON.parse('{"title":"Introdução","description":"","frontmatter":{},"headers":[],"relativePath":"docs/lucid/guides/introduction.md","filePath":"docs/lucid/guides/introduction.md"}'),d={name:"docs/lucid/guides/introduction.md"};function t(i,e,n,c,u,l){return r(),o("div",null,e[0]||(e[0]=[s('<h1 id="introducao" tabindex="-1">Introdução <a class="header-anchor" href="#introducao" aria-label="Permalink to &quot;Introdução&quot;">​</a></h1><p>O Lucid é um construtor de consultas SQL e um ORM do Active Record construído sobre o <a href="https://knexjs.org/" target="_blank" rel="noreferrer">Knex</a>. O Lucid se esforça para alavancar o SQL em seu potencial máximo e oferece uma API limpa para muitas operações SQL avançadas.</p><p>A seguir estão alguns dos recursos selecionados do Lucid.</p><ul><li>Um construtor de consultas fluente construído sobre o Knex.</li><li>Suporte para réplicas de leitura e gravação e gerenciamento de múltiplas conexões.</li><li>Modelos baseados em classe que aderem ao padrão do Active Record.</li><li>Sistema de migração para modificar o esquema do banco de dados usando conjuntos de alterações incrementais.</li><li>Fábricas de modelos para gerar dados falsos para teste.</li><li>Semeadores de banco de dados para inserir dados iniciais/fictícios no banco de dados.</li></ul><h2 id="um-construtor-de-consultas-fluente" tabindex="-1">Um construtor de consultas fluente <a class="header-anchor" href="#um-construtor-de-consultas-fluente" aria-label="Permalink to &quot;Um construtor de consultas fluente&quot;">​</a></h2><p>A camada base do Lucid é um construtor de consultas fluente que você pode usar para construir consultas SQL usando uma API JavaScript. O construtor de consultas usa <a href="https://knexjs.org/" target="_blank" rel="noreferrer">Knex</a> por baixo dos panos e, portanto, ele suporta muitas operações SQL avançadas como <strong>funções de janela</strong>, <strong>CTEs recursivas</strong>, <strong>operações JSON</strong>, <strong>bloqueios baseados em linha</strong> e muito mais.</p><p>O Knex pode não ser o construtor de consultas mais moderno no ecossistema Node.js. No entanto, ele é maduro e testado em batalha.</p><p>Veja também: <a href="./installation.html#basic-usage">Usando o construtor de consultas</a></p><h2 id="sistema-de-migracao" tabindex="-1">Sistema de migração <a class="header-anchor" href="#sistema-de-migracao" aria-label="Permalink to &quot;Sistema de migração&quot;">​</a></h2><p>Inspirado em frameworks como Laravel, Rails e Elixir Ecto, o AdonisJS não infere alterações de esquema de modelos. Em vez disso, ele faz você escrever os conjuntos de alterações incrementais para modificar o esquema do banco de dados. As migrações manuais podem parecer muita digitação. No entanto, a flexibilidade e o controle que elas fornecem são incomparáveis.</p><p>Temos experimentado que em aplicativos do mundo real, uma alteração de esquema não é apenas adicionar novas colunas. Às vezes, as alterações envolvem renomear colunas, preservar dados, criar uma nova tabela e copiar dados de uma tabela antiga. Tudo isso deve ser feito sem bloquear as tabelas por um longo período.</p><p>As migrações manuais garantem que você possa expressar alterações de esquema de acordo com os requisitos do seu aplicativo.</p><p>Veja também: <a href="./../migrations/introduction.html">Criando migrações</a></p><h2 id="orm-de-registro-ativo" tabindex="-1">ORM de registro ativo <a class="header-anchor" href="#orm-de-registro-ativo" aria-label="Permalink to &quot;ORM de registro ativo&quot;">​</a></h2><p>A camada ORM do AdonisJS usa classes JavaScript para definir modelos de dados. As classes podem definir ganchos de ciclo de vida, criar propriedades e métodos personalizados para encapsular a lógica de domínio e controlar o comportamento de serialização do modelo.</p><p>Você cria um modelo para cada tabela de banco de dados dentro do seu aplicativo e usa as APIs que os modelos oferecem para interagir com ele.</p><p><a href="./../models/introduction.html">Usando modelos</a></p><h2 id="fabricas-de-modelos-e-seeders-de-banco-de-dados" tabindex="-1">Fábricas de modelos e seeders de banco de dados <a class="header-anchor" href="#fabricas-de-modelos-e-seeders-de-banco-de-dados" aria-label="Permalink to &quot;Fábricas de modelos e seeders de banco de dados&quot;">​</a></h2><p>As fábricas de modelos são usadas para gerar/persistir instâncias de modelo com dados falsos. Eles são úteis durante os testes, pois você pode encapsular a lógica de geração de dados fictícios em um só lugar e reutilizar fábricas nos testes.</p><p>Por outro lado, os seeders de banco de dados são usados ​​para semear o banco de dados com alguns valores iniciais. Esses valores podem ser dados fictícios que você deseja usar durante o desenvolvimento. Ou você pode usar seeders para configurar o estado inicial do seu aplicativo de produção com uma lista de países, usuários administradores e assim por diante.</p><p><a href="./../models/model_factories.html">Fábricas de modelos</a><a href="./seeders.html">Seeders de banco de dados</a></p><h2 id="lucid-nao-e-seguro-para-tipos" tabindex="-1">Lucid não é seguro para tipos <a class="header-anchor" href="#lucid-nao-e-seguro-para-tipos" aria-label="Permalink to &quot;Lucid não é seguro para tipos&quot;">​</a></h2><p>Lucid não é seguro para tipos. Vamos discutir o porquê.</p><p>A segurança de tipos com ORMs SQL é um tópico complexo, pois deve ser aplicado em várias camadas, como construção e saída de consultas.</p><p>Muitos construtores de consultas e ORMs são seguros para tipos apenas com a saída da consulta (às vezes, eles também limitam os recursos SQL), e apenas alguns são seguros para tipos com construção de consultas também. Kysely é um deles.</p><p>Eu <a href="https://github.com/thetutlage/meta/discussions/8" target="_blank" rel="noreferrer">escrevi algumas centenas de palavras</a> comparando Kysely e Drizzle ORM que podem ajudar você a entender corretamente as camadas de segurança de tipo.</p><p>Se tomarmos Kysely como o padrão ouro de segurança de tipo, perdemos muita flexibilidade com ele. Especialmente, de certa forma, estendemos e usamos Lucid em toda a base de código AdonisJS.</p><p>Na verdade, eu o usei para criar uma extensão para nosso módulo Auth e os auxiliares que os modelos Lucid podem usar. E falhei nas duas vezes. Os <a href="https://www.answeroverflow.com/m/1179612569774870548" target="_blank" rel="noreferrer">criadores do Kysely também confirmaram</a> que criar abstrações genéricas do Kysely é impossível.</p><p>Isso não quer dizer que Kysely seja limitante em primeiro lugar. Ele está limitando como queremos usar, ou seja, construir abstrações genéricas e integrá-las perfeitamente com o resto da estrutura. Kysely é uma ferramenta excelente para uso direto.</p><p>Dito isso, olhando para os recursos à nossa disposição e nossos objetivos, o Lucid não será tão seguro para tipos quanto o Kysely no futuro próximo. No entanto, podemos investir algum tempo para tornar certas partes do ORM seguras para tipos.</p>',30)]))}const g=a(d,[["render",t]]);export{p as __pageData,g as default};
