# Controladores

Controladores sÃ£o a maneira de fato de lidar com solicitaÃ§Ãµes HTTP no AdonisJS. Eles permitem que vocÃª limpe o arquivo de rotas movendo todos os manipuladores de rota em linha para seus arquivos de controlador dedicados.

No AdonisJS, os controladores sÃ£o armazenados dentro (mas nÃ£o limitados a) o diretÃ³rio `app/Controllers/Http` e cada arquivo representa um Ãºnico controlador.

VocÃª quer extrair um mÃ©todo de controlador complexo para seu prÃ³prio arquivo?

Use um [Controlador de AÃ§Ã£o Ãšnica](https://docs.adonisjs.com/guides/controllers#single-action-controllers)!

```ts
// app/Controllers/Http/PostsController.ts

import { HttpContextContract } from '@ioc:Adonis/Core/HttpContext'

export default class PostsController {
  public async index(ctx: HttpContextContract) {
    return [
      {
        id: 1,
        title: 'Hello world',
      },
      {
        id: 2,
        title: 'Hello universe',
      },
    ]
  }
}
```

VocÃª terÃ¡ que referenciÃ¡-lo como um manipulador de rota dentro do arquivo `start/routes.ts` para usar este controlador.

```ts
Route.get('posts', 'PostsController.index')
```

## LocalizaÃ§Ã£o dos controladores

Convencionalmente, os controladores sÃ£o armazenados dentro do diretÃ³rio `app/Controllers/Http`, mas nÃ£o Ã© uma regra rÃ­gida, e vocÃª pode modificar a localizaÃ§Ã£o deles dentro do arquivo `.adonisrc.json`.

```json
{
  "namespaces": {
    "httpControllers": "App/Controllers"
  }
}
```

Agora, o AdonisJS encontrarÃ¡ os controladores dentro do diretÃ³rio `App/Controllers`. AlÃ©m disso, o comando `make:controller` os criarÃ¡ dentro do local correto.

::: info NOTA
Seu controlador nÃ£o precisa estar dentro de apenas um diretÃ³rio. VocÃª pode movÃª-los livremente dentro da estrutura do seu aplicativo.
Certifique-se de exigi-los corretamente na sua declaraÃ§Ã£o de rota.
:::

### Namespace de rota

Ao ter diferentes locais para seu controlador, pode ser conveniente definir o namespace de seus controladores usando grupos de rota.

```ts
Route.group(() => {
  Route.get('cart', 'CartController.index')
  Route.put('cart', 'CartController.update')
}).namespace('App/Modules/Checkout')
```

O `CartController` serÃ¡ importado de `App/Modules/Checkout` neste exemplo.

::: info NOTA
O namespace deve ser um caminho absoluto da raiz do seu aplicativo.
:::

## Comando Make controller

VocÃª pode usar o seguinte comando `node ace` para criar um novo controlador.

```sh
node ace make:controller Post

# CREATE: app/Controllers/Http/PostsController.ts
```

Se vocÃª notar, no comando acima, mencionamos a palavra `Post` como singular, enquanto o nome do arquivo gerado estÃ¡ no plural e tem um sufixo `Controller`.

O AdonisJS aplica essas transformaÃ§Ãµes para garantir que os nomes dos arquivos sejam consistentes em todo o seu projeto. No entanto, vocÃª pode instruir a CLI a nÃ£o aplicar essas transformaÃ§Ãµes usando o sinalizador `--exact`.

![](/docs/assets/controller-help-exact-flag.webp)

## ReferÃªncia de rotas do controlador

Como vocÃª pode notar, os controladores sÃ£o referenciados em rotas como uma expressÃ£o de string, ou seja, `'Controller.method'`. Optamos por essa abordagem intencionalmente em favor de controladores de carregamento lento e sintaxe menos detalhada.

Vamos ver como o arquivo de rotas pode ficar se decidirmos **NÃƒO usar** a expressÃ£o de string.

```ts
import Route from '@ioc:Adonis/Core/Route'
import PostsController from 'App/Controllers/Http/PostsController'

Route.get('/posts', async (ctx) => {
  return new PostsController().index(ctx)
})
```

No exemplo acima, importamos o `PostsController` dentro do arquivo de rotas. Em seguida, criamos uma instÃ¢ncia e executamos o mÃ©todo `index`, passando o objeto `ctx`.

Agora imagine um aplicativo com 40-50 controladores diferentes. Cada controlador tem seu conjunto de importaÃ§Ãµes, todos sendo puxados para baixo dentro de um Ãºnico arquivo de rotas, tornando o arquivo de rotas um ponto de estrangulamento.

### Carregamento lento

O carregamento lento dos controladores Ã© uma soluÃ§Ã£o perfeita para o problema mencionado acima. NÃ£o hÃ¡ necessidade de importar tudo no nÃ­vel superior; em vez disso, importe os controladores conforme necessÃ¡rio.

```ts
import Route from '@ioc:Adonis/Core/Route'

Route.get('/posts', async (ctx) => {
  const { default: PostsController } = await import(
    'App/Controllers/Http/PostsController'
  )
  return new PostsController().index(ctx)
})
```

Importar manualmente o controlador, instanciar a instÃ¢ncia da classe ainda Ã© muito cÃ³digo, considerando que um aplicativo de tamanho decente pode passar de 100 rotas.

### Apostando no futuro do TypeScript

A referÃªncia baseada em string fornece o melhor dos dois mundos. Os controladores sÃ£o carregados lentamente e a sintaxe Ã© concisa.

No entanto, isso tem a desvantagem de nÃ£o ser seguro para o tipo. O IDE nÃ£o reclama se o controlador ou o mÃ©todo estiver faltando ou tiver um erro de digitaÃ§Ã£o.

O lado bom Ã© que tornar a expressÃ£o de string segura para o tipo nÃ£o Ã© impossÃ­vel. O TypeScript jÃ¡ estÃ¡ progredindo nessa direÃ§Ã£o. Precisamos de duas coisas para atingir a seguranÃ§a do tipo ao referenciar a expressÃ£o de string `'Controller.method'`.

- [Prova de conceito](https://www.typescriptlang.org/play?ts=4.1.3#code/MYewdgzgLgBASiArlApjAvDA3gKBjAcxSgB4AJAQzABMAbFAJxhQA9UaIZoGBLMAgHwAKAA4UoqBmABcXKL34AaGAAsqdRrMo16DAJSyY2jU1btqnAAYASLHwBmjGAEEAvgDpbDpwCFXlmAB+bDx8GFAweRBaXVlLZxERAHoAYXAomMYIJLIJZNs3S0VQ-ABbYhUQalkfUNcYWUQwAGswEAB3MBxXHF6kpKMQADcnYacoFTQAIgYkVCmYIYpeCgAjehh1LhQ0CfEYdrRlo-XdkBgxBggjuQUCGD4oc6fmlEgcCOgYWeQ0TARfu4iFAhAByJKg5SgsggcppSKzTIMdx8aisUF6IA) para o mesmo.

- [Uma questÃ£o em aberto](https://github.com/microsoft/TypeScript/issues/31090) e estamos otimistas de que ela chegarÃ¡ ao TypeScript no futuro, pois adere aos objetivos de design do TypeScript.

## Controladores de aÃ§Ã£o Ãºnica

O AdonisJS fornece uma maneira de definir um controlador de aÃ§Ã£o Ãºnica. Ã‰ uma maneira eficaz de encapsular a funcionalidade em classes claramente nomeadas. Para fazer isso, vocÃª precisa definir um mÃ©todo `handle` dentro do controlador.

```ts
import type { HttpContextContract } from '@ioc:Adonis/Core/HttpContext'

export default class RegisterNewsletterSubscriptionController {
  public async handle({}: HttpContextContract) {
    // ...
  }
}
```

EntÃ£o, vocÃª pode referenciar o controlador na rota como uma expressÃ£o de string.

```ts
Route.post('/newsletter', 'RegisterNewsletterSubscriptionController')
```

## OperaÃ§Ãµes CRUD

Os princÃ­pios de [REST](https://en.wikipedia.org/wiki/Representational_state_transfer) fornecem uma Ã³tima maneira de mapear operaÃ§Ãµes CRUD com mÃ©todos HTTP sem tornar as URLs detalhadas.

Por exemplo, a URL `/posts` pode ser usada para **visualizar todas as postagens** e **criar uma nova postagem**, apenas usando o mÃ©todo HTTP correto.

```ts
Route.get('/posts', () => {
  return 'List of posts'
})

// ğŸ‘‡
Route.post('/posts', () => {
  return 'Create a new post'
})
```

Aqui estÃ¡ a lista de todas as rotas para executar operaÃ§Ãµes CRUD.

```ts
Route.get('/posts', () => {
  return 'List all posts'
})

Route.get('/posts/create', () => {
  return 'Display a form to create a post'
})

Route.post('/posts', async () => {
  return 'Handle post creation form request'
})

Route.get('/posts/:id', () => {
  return 'Return a single post'
})

Route.get('/posts/:id/edit', () => {
  return 'Display a form to edit a post'
})

Route.put('/posts/:id', () => {
  return 'Handle post update form submission'
})

Route.delete('/posts/:id', () => {
  return 'Delete post'
})
```

## Rotas e controladores engenhosos

Como as rotas [acima mencionadas](#crud-operations) estÃ£o usando uma convenÃ§Ã£o predefinida. O AdonisJS fornece um atalho para registrar todas as rotas juntas usando o mÃ©todo `Route.resource`.

```ts
Route.resource('posts', 'PostsController')
```

A seguir estÃ¡ a lista de rotas registradas.

![](/docs/assets/routes-list.png)

### Nomeando rotas

Como vocÃª pode notar, cada rota registrada pelo recurso recebe um nome. O nome da rota Ã© criado combinando o **nome do recurso** e a **aÃ§Ã£o** realizada pela rota. Por exemplo:

- `posts.create` significa uma rota para exibir o formulÃ¡rio para criar uma nova postagem
- `posts.store` representa uma rota para criar uma nova postagem e assim por diante.

Usando o mÃ©todo `.as`, vocÃª pode alterar o prefixo antes do nome da aÃ§Ã£o.

```ts
Route.resource('posts', 'PostsController').as('articles')
```

```txt
articles.index
articles.create
articles.store
articles.show
articles.edit
articles.update
articles.destroy
```

### Filtrando rotas

Em muitas situaÃ§Ãµes, vocÃª deseja evitar que algumas das rotas Ãºteis sejam registradas. Por exemplo, vocÃª decide restringir os usuÃ¡rios do seu blog de **atualizar** ou **excluir** seus comentÃ¡rios e, portanto, as rotas para o mesmo nÃ£o sÃ£o necessÃ¡rias.

```ts
Route
  .resource('comments', 'CommentsController')
  .except(['update', 'destroy']) // ğŸ‘ˆ
```

O oposto do mÃ©todo `except` Ã© o mÃ©todo `only`. Ele registra apenas as rotas com os nomes de aÃ§Ã£o fornecidos.

```ts
Route
  .resource('comments', 'CommentsController')
  .only(['index', 'show', 'store']) // ğŸ‘ˆ
```

### Rotas somente para API

Ao criar um servidor de API, as rotas para exibir os formulÃ¡rios sÃ£o redundantes, pois vocÃª criarÃ¡ esses formulÃ¡rios em seu frontend ou no aplicativo mÃ³vel. VocÃª pode remover essas rotas chamando o mÃ©todo `apiOnly`.

```ts
Route.resource('posts', 'PostsController').apiOnly() // ğŸ‘ˆ
```

### Aplicando middleware

O mÃ©todo `.middleware` tambÃ©m aplica middleware em todos ou em conjuntos selecionados de rotas registradas por um determinado recurso.

```ts
Route.resource('users', 'UsersController').middleware({
  '*': ['auth'],
})
```

Ou aplique middleware somente a aÃ§Ãµes selecionadas. No exemplo a seguir, a chave do objeto deve ser o nome da aÃ§Ã£o.

```ts
Route.resource('users', 'UsersController').middleware({
  create: ['auth'],
  store: ['auth'],
  destroy: ['auth'],
})
```

### Renomeando nome do parÃ¢metro de recurso
O parÃ¢metro para visualizar uma Ãºnica instÃ¢ncia de um recurso Ã© nomeado como `id`. No entanto, vocÃª pode renomeÃ¡-lo para outra coisa usando o mÃ©todo `paramFor`.

```ts {3}
Route
  .resource('users', 'UsersController')
  .paramFor('users', 'user')
```

O exemplo acima gerarÃ¡ as seguintes rotas.

```sh
# Exibindo rotas somente com parÃ¢metros

GET /users/:user
GET /users/:user/edit
PUT,PATCH /users/:user
DELETE /users/:user
```

VocÃª tambÃ©m pode renomear recursos aninhados e superficiais. Por exemplo:

```ts
Route
  .resource('posts.comments', 'CommentsController')
  .paramFor('posts', 'post')
  .paramFor('comments', 'comment')
```

## Recursos aninhados

VocÃª tambÃ©m pode registrar recursos aninhados separando cada recurso com uma `notaÃ§Ã£o de ponto (.)`. Por exemplo:

```ts
Route.resource('posts.comments', 'CommentsController')
```

![](/docs/assets/nested-resource.webp)

Como vocÃª pode notar, o id do recurso pai Ã© prefixado com o nome do recurso. ou seja, `post_id`.

## Recursos superficiais

Em recursos aninhados, cada recurso filho Ã© prefixado com o nome do recurso pai e seu id. Por exemplo:

- `/posts/:post_id/comments`: Exibir todos os comentÃ¡rios para o post
- `/posts/:post_id/comments/:id`: Exibir todos os comentÃ¡rios por id.

A existÃªncia de `:post_id` na segunda rota Ã© irrelevante, pois vocÃª pode procurar o comentÃ¡rio diretamente por seu id.

Para manter a estrutura de URL plana (sempre que possÃ­vel), vocÃª pode usar recursos superficiais.

```ts
Route.shallowResource('posts.comments', 'CommentsController')
```

![](/docs/assets/shallow-resource.webp)

## Reutilizando controladores

Muitos desenvolvedores tendem a cometer o erro de tentar reutilizar controladores importando-os dentro de outros controladores.

Se vocÃª quiser reutilizar alguma lÃ³gica dentro do seu aplicativo, vocÃª deve extrair esse pedaÃ§o de cÃ³digo para sua classe ou objeto, geralmente conhecidos como objetos de serviÃ§o.

Recomendamos fortemente tratar seus controladores como **saltos de trÃ¡fego**, cujo trabalho Ã© **aceitar a solicitaÃ§Ã£o HTTP**, **atribuir trabalho** para as outras partes do aplicativo e **retornar uma resposta**. Toda a lÃ³gica reutilizÃ¡vel deve viver fora do controlador.
