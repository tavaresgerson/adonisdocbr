# Regras de valida√ß√£o personalizadas

Voc√™ pode adicionar regras personalizadas ao validador usando o m√©todo `validator.rule`. As regras devem ser registradas apenas uma vez. Portanto, recomendamos que voc√™ as registre dentro de um provedor de servi√ßos ou um [arquivo de pr√©-carregamento](../fundamentals/adonisrc-file.md#preloads).

Ao longo deste guia, n√≥s as manteremos dentro do arquivo `start/validator.ts`. Voc√™ pode criar este arquivo executando o seguinte comando Ace e selecionando o ambiente como **"Durante o servidor HTTP"**.

```sh
node ace make:prldfile validator
```

![](/docs/assets/validator-prldfile_wipxtd.webp)

Abra o arquivo rec√©m-criado e cole o seguinte c√≥digo dentro dele.

```ts
// start/validator.ts

import { string } from '@ioc:Adonis/Core/Helpers'
import { validator } from '@ioc:Adonis/Core/Validator'

validator.rule('camelCase', (value, _, options) => {
  if (typeof value !== 'string') {
    return
  }

  if (value !== string.camelCase(value)) {
    options.errorReporter.report(
      options.pointer,
      'camelCase',
      'camelCase validation failed',
      options.arrayExpressionPointer
    )
  }
})
```

- O m√©todo `validator.rule` aceita o nome da regra como o primeiro argumento.
- O segundo argumento √© a implementa√ß√£o da regra. A fun√ß√£o recebe o valor do campo em valida√ß√£o, as op√ß√µes de regra e um objeto que representa a √°rvore de esquema.

No exemplo acima, criamos uma regra `camelCase` que verifica se o valor do campo √© o mesmo que sua vers√£o camelCase ou n√£o. Caso contr√°rio, reportaremos um erro usando a inst√¢ncia de classe [errorReporter](https://github.com/adonisjs/validator/blob/develop/src/ErrorReporter/Vanilla.ts#L39).

## Usando a regra
Antes de usar suas regras personalizadas, voc√™ ter√° que informar o compilador TypeScript sobre o mesmo. Caso contr√°rio, ele reclamar√° que a regra n√£o existe.

Para informar o TypeScript, usaremos [declaration merging](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#merging-interfaces) e adicionaremos a propriedade √† interface `Rules`.

Crie um novo arquivo no caminho `contracts/validator.ts` (o nome do arquivo n√£o √© importante) e cole o seguinte conte√∫do dentro dele.

```ts
// contracts/validator.ts

declare module '@ioc:Adonis/Core/Validator' {
  interface Rules {
    camelCase(): Rule
  }
}
```

Uma vez feito isso, voc√™ pode acessar a regra `camelCase` do objeto `rules`.

```ts {1,6}
import { rules, schema, validator } from '@ioc:Adonis/Core/Validator'

await validator.validate({
  schema: schema.create({
    fileName: schema.string([
      rules.camelCase()
    ]),
  }),
  data: {},
})
```

## Passando op√ß√µes para a regra
As regras tamb√©m podem aceitar op√ß√µes, e elas estar√£o dispon√≠veis para o retorno de chamada de valida√ß√£o como o segundo argumento.

Desta vez, vamos come√ßar pela interface TypeScript e definir as op√ß√µes que esperamos do consumidor da regra.

```ts
// contracts/validator.ts

declare module '@ioc:Adonis/Core/Validator' {
  interface Rules {
    camelCase(maxLength?: number): Rule
  }
}
```

Todos os argumentos passados ‚Äã‚Äãpara a fun√ß√£o de regra est√£o dispon√≠veis como uma matriz para a implementa√ß√£o da regra. Ent√£o, por exemplo, voc√™ pode acessar a op√ß√£o `maxLength` da seguinte forma.

```ts {3,10}
validator.rule('camelCase', (
  value,
  [maxLength],
  options
) => {
  // Rest of the validation
  if (maxLength && value.length > maxLength) {
    options.errorReporter.report(
      options.pointer,
      'camelCase.maxLength', // üëà Fique de olho nisso
      'camelCase.maxLength validation failed',
      options.arrayExpressionPointer,
      { maxLength }
    )
  }
})
```

Finalmente, se voc√™ notar, estamos passando o nome da regra como `camelCase.maxLength` para o relator de erros. Isso permitir√° que os usu√°rios definam uma mensagem de valida√ß√£o personalizada apenas para o `maxLength`.

```ts
messages: {
  'camelCase.maxLength': 'Only {{ options.maxLength }} characters are allowed'
}
```

### Normalizando op√ß√µes
Muitas vezes voc√™ deseja normalizar as op√ß√µes passadas para uma regra de valida√ß√£o. Por exemplo: usando um `maxLength` padr√£o quando n√£o fornecido pelo usu√°rio.

Em vez de normalizar as op√ß√µes dentro do retorno de chamada de valida√ß√£o, recomendamos que voc√™ as normalize apenas uma vez durante a fase de compila√ß√£o.

O m√©todo `validator.rule` aceita uma fun√ß√£o de retorno de chamada como o terceiro argumento e a executa durante a fase de compila√ß√£o.

```ts {4-10}
validator.rule(
  'camelCase', // nome da regra
  () => {}, // retorno de chamada de valida√ß√£o
  ([maxLength]) => {
    return {
      compiledOptions: {
        maxLength: maxLength || 10,
      },
    }
  }
)
```

O valor `compiledOptions` √© ent√£o passado para o retorno de chamada de valida√ß√£o como o segundo argumento. Conforme o exemplo acima, o retorno de chamada de valida√ß√£o receber√° o `maxLength` como um objeto.

```ts {3}
validator.rule(
  'camelCase', // nome da regra
  (value, { maxLength }) => {}, // retorno de chamada de valida√ß√£o
  ([maxLength]) => {
    return {
      compiledOptions: {
        maxLength: maxLength || 10,
      },
    }
  }
)
```

## Regras ass√≠ncronas
Para otimizar o processo de valida√ß√£o, voc√™ ter√° que informar explicitamente ao validador que sua regra de valida√ß√£o √© ass√≠ncrona por natureza. Basta retornar `async: true` do retorno de chamada de compila√ß√£o e ent√£o voc√™ poder√° usar `async/await` dentro do retorno de chamada de valida√ß√£o.

```ts {3,6}
validator.rule(
  'camelCase', // nome da regra
  async () => {}, // retorno de chamada de valida√ß√£o
  () => {
    return {
      async: true,
      compiledOptions: {},
    }
  }
)
```

## Restringir regras para trabalhar em um tipo de dado espec√≠fico
Dentro do retorno de chamada de compila√ß√£o, voc√™ pode acessar o **tipo/subtipo de esquema** do campo no qual a regra de valida√ß√£o √© aplicada e ent√£o permitir condicionalmente que ele seja usado somente em tipos espec√≠ficos.

A seguir est√° um exemplo de restri√ß√£o da regra `camelCase` somente a um tipo de esquema de string.

```ts
validator.rule(
  'camelCase', // nome da regra
  async () => {}, // retorno de chamada de valida√ß√£o
  (options, type, subtype) => {
    if (subtype !== 'string') {
      throw new Error('"camelCase" rule can only be used with a string schema type')
    }

    return {
      compiledOptions: {},
    }
  }
)
```

Uma exce√ß√£o ser√° gerada se algu√©m tentar usar a regra `camelCase` em um campo n√£o string.

```ts
schema: schema.create({
  fileName: schema.number([
    rules.camelCase() // resultar√° em um erro em tempo de execu√ß√£o
  ]),
}),
```
