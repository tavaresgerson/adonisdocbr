{
  "version": 3,
  "sources": ["../src/index.js", "../node_modules/.pnpm/regex-utilities@2.3.0/node_modules/regex-utilities/src/index.js"],
  "sourcesContent": ["import {Context, forEachUnescaped, getGroupContents, hasUnescaped, replaceUnescaped} from 'regex-utilities';\n\nconst r = String.raw;\nconst gRToken = r`\\\\g<(?<gRNameOrNum>[^>&]+)&R=(?<gRDepth>[^>]+)>`;\nconst recursiveToken = r`\\(\\?R=(?<rDepth>[^\\)]+)\\)|${gRToken}`;\nconst namedCapturingDelim = r`\\(\\?<(?![=!])(?<captureName>[^>]+)>`;\nconst token = new RegExp(r`${namedCapturingDelim}|${recursiveToken}|\\(\\?|\\\\?.`, 'gsu');\nconst overlappingRecursionMsg = 'Cannot use multiple overlapping recursions';\n// See <github.com/slevithan/regex/blob/main/src/subclass.js>\nconst emulationGroupMarker = '$E$';\n\n/**\n@param {string} expression\n@param {{\n  flags?: string;\n  useEmulationGroups?: boolean;\n}} [data]\n@returns {string}\n*/\nexport function recursion(expression, data) {\n  // Keep the initial fail-check (which avoids unneeded processing) as fast as possible by testing\n  // without the accuracy improvement of using `hasUnescaped` with default `Context`\n  if (!(new RegExp(recursiveToken, 'su').test(expression))) {\n    return expression;\n  }\n  if (hasUnescaped(expression, r`\\(\\?\\(DEFINE\\)`, Context.DEFAULT)) {\n    throw new Error('DEFINE groups cannot be used with recursion');\n  }\n  const useEmulationGroups = !!data?.useEmulationGroups;\n  const hasNumberedBackref = hasUnescaped(expression, r`\\\\[1-9]`, Context.DEFAULT);\n  const groupContentsStartPos = new Map();\n  const openGroups = [];\n  let hasRecursed = false;\n  let numCharClassesOpen = 0;\n  let numCaptures = 0;\n  let match;\n  token.lastIndex = 0;\n  while ((match = token.exec(expression))) {\n    const {0: m, groups: {captureName, rDepth, gRNameOrNum, gRDepth}} = match;\n    if (m === '[') {\n      numCharClassesOpen++;\n    } else if (!numCharClassesOpen) {\n\n      // `(?R=N)`\n      if (rDepth) {\n        assertMaxInBounds(rDepth);\n        if (hasRecursed) {\n          throw new Error(overlappingRecursionMsg);\n        }\n        if (hasNumberedBackref) {\n          // Could add support for numbered backrefs with extra effort, but it's probably not worth\n          // it. To trigger this error, the regex must include recursion and one of the following:\n          // - An interpolated regex that contains a numbered backref (since other numbered\n          //   backrefs are prevented by implicit flag n).\n          // - A numbered backref, when flag n is explicitly disabled.\n          // Note that Regex+'s extended syntax (atomic groups and sometimes subroutines) can also\n          // add numbered backrefs, but those work fine because external plugins like this one run\n          // *before* the transformation of built-in syntax extensions\n          throw new Error('Numbered backrefs cannot be used with global recursion');\n        }\n        const pre = expression.slice(0, match.index);\n        const post = expression.slice(token.lastIndex);\n        if (hasUnescaped(post, recursiveToken, Context.DEFAULT)) {\n          throw new Error(overlappingRecursionMsg);\n        }\n        // No need to parse further\n        return makeRecursive(pre, post, +rDepth, false, useEmulationGroups);\n      // `\\g<name&R=N>`, `\\g<number&R=N>`\n      } else if (gRNameOrNum) {\n        assertMaxInBounds(gRDepth);\n        let isWithinReffedGroup = false;\n        for (const g of openGroups) {\n          if (g.name === gRNameOrNum || g.num === +gRNameOrNum) {\n            isWithinReffedGroup = true;\n            if (g.hasRecursedWithin) {\n              throw new Error(overlappingRecursionMsg);\n            }\n            break;\n          }\n        }\n        if (!isWithinReffedGroup) {\n          throw new Error(r`Recursive \\g cannot be used outside the referenced group \"\\g<${gRNameOrNum}&R=${gRDepth}>\"`);\n        }\n        const startPos = groupContentsStartPos.get(gRNameOrNum);\n        const groupContents = getGroupContents(expression, startPos);\n        if (\n          hasNumberedBackref &&\n          hasUnescaped(groupContents, r`${namedCapturingDelim}|\\((?!\\?)`, Context.DEFAULT)\n        ) {\n          throw new Error('Numbered backrefs cannot be used with recursion of capturing groups');\n        }\n        const groupContentsPre = expression.slice(startPos, match.index);\n        const groupContentsPost = groupContents.slice(groupContentsPre.length + m.length);\n        const expansion = makeRecursive(groupContentsPre, groupContentsPost, +gRDepth, true, useEmulationGroups);\n        const pre = expression.slice(0, startPos);\n        const post = expression.slice(startPos + groupContents.length);\n        // Modify the string we're looping over\n        expression = `${pre}${expansion}${post}`;\n        // Step forward for the next loop iteration\n        token.lastIndex += expansion.length - m.length - groupContentsPre.length - groupContentsPost.length;\n        openGroups.forEach(g => g.hasRecursedWithin = true);\n        hasRecursed = true;\n      } else if (captureName) {\n        numCaptures++;\n        groupContentsStartPos.set(String(numCaptures), token.lastIndex);\n        groupContentsStartPos.set(captureName, token.lastIndex);\n        openGroups.push({\n          num: numCaptures,\n          name: captureName,\n        });\n      } else if (m.startsWith('(')) {\n        const isUnnamedCapture = m === '(';\n        if (isUnnamedCapture) {\n          numCaptures++;\n          groupContentsStartPos.set(String(numCaptures), token.lastIndex);\n        }\n        openGroups.push(isUnnamedCapture ? {num: numCaptures} : {});\n      } else if (m === ')') {\n        openGroups.pop();\n      }\n\n    } else if (m === ']') {\n      numCharClassesOpen--;\n    }\n  }\n\n  return expression;\n}\n\n/**\n@param {string} max\n*/\nfunction assertMaxInBounds(max) {\n  const errMsg = `Max depth must be integer between 2 and 100; used ${max}`;\n  if (!/^[1-9]\\d*$/.test(max)) {\n    throw new Error(errMsg);\n  }\n  max = +max;\n  if (max < 2 || max > 100) {\n    throw new Error(errMsg);\n  }\n}\n\n/**\n@param {string} pre\n@param {string} post\n@param {number} maxDepth\n@param {boolean} isSubpattern\n@param {boolean} useEmulationGroups\n@returns {string}\n*/\nfunction makeRecursive(pre, post, maxDepth, isSubpattern, useEmulationGroups) {\n  const namesInRecursed = new Set();\n  // Avoid this work if not needed\n  if (isSubpattern) {\n    forEachUnescaped(pre + post, namedCapturingDelim, ({groups: {captureName}}) => {\n      namesInRecursed.add(captureName);\n    }, Context.DEFAULT);\n  }\n  const reps = maxDepth - 1;\n  // Depth 2: 'pre(?:pre(?:)post)post'\n  // Depth 3: 'pre(?:pre(?:pre(?:)post)post)post'\n  return `${pre}${\n    repeatWithDepth(`(?:${pre}`, reps, (isSubpattern ? namesInRecursed : null), 'forward', useEmulationGroups)\n  }(?:)${\n    repeatWithDepth(`${post})`, reps, (isSubpattern ? namesInRecursed : null), 'backward', useEmulationGroups)\n  }${post}`;\n}\n\n/**\n@param {string} expression\n@param {number} reps\n@param {Set<string> | null} namesInRecursed\n@param {'forward' | 'backward'} direction\n@param {boolean} useEmulationGroups\n@returns {string}\n*/\nfunction repeatWithDepth(expression, reps, namesInRecursed, direction, useEmulationGroups) {\n  const startNum = 2;\n  const depthNum = i => direction === 'backward' ? reps - i + startNum - 1 : i + startNum;\n  let result = '';\n  for (let i = 0; i < reps; i++) {\n    const captureNum = depthNum(i);\n    result += replaceUnescaped(\n      expression,\n      r`${namedCapturingDelim}|\\\\k<(?<backref>[^>]+)>${useEmulationGroups ? r`|\\((?!\\?)` : ''}`,\n      ({0: m, groups: {captureName, backref}}) => {\n        if (backref && namesInRecursed && !namesInRecursed.has(backref)) {\n          // Don't alter backrefs to groups outside the recursed subpattern\n          return m;\n        }\n        if (m === '(') {\n          return `(${emulationGroupMarker}`;\n        }\n        const suffix = `_$${captureNum}`;\n        return captureName ?\n          `(?<${captureName}${suffix}>${useEmulationGroups ? emulationGroupMarker : ''}` :\n          r`\\k<${backref}${suffix}>`;\n      },\n      Context.DEFAULT\n    );\n  }\n  return result;\n}\n", "// Constant properties for tracking regex syntax context\nexport const Context = Object.freeze({\n  DEFAULT: 'DEFAULT',\n  CHAR_CLASS: 'CHAR_CLASS',\n});\n\n/**\nReplaces all unescaped instances of a regex pattern in the given context, using a replacement\nstring or callback.\n\nDoesn't skip over complete multicharacter tokens (only `\\` plus its folowing char) so must be used\nwith knowledge of what's safe to do given regex syntax. Assumes UnicodeSets-mode syntax.\n@param {string} expression Search target\n@param {string} needle Search as a regex pattern, with flags `su` applied\n@param {string | (match: RegExpExecArray, details: {\n  context: 'DEFAULT' | 'CHAR_CLASS';\n  negated: boolean;\n}) => string} replacement\n@param {'DEFAULT' | 'CHAR_CLASS'} [context] All contexts if not specified\n@returns {string} Updated expression\n@example\nconst str = '.\\\\.\\\\\\\\.[[\\\\.].].';\nreplaceUnescaped(str, '\\\\.', '@');\n// \u2192 '@\\\\.\\\\\\\\@[[\\\\.]@]@'\nreplaceUnescaped(str, '\\\\.', '@', Context.DEFAULT);\n// \u2192 '@\\\\.\\\\\\\\@[[\\\\.].]@'\nreplaceUnescaped(str, '\\\\.', '@', Context.CHAR_CLASS);\n// \u2192 '.\\\\.\\\\\\\\.[[\\\\.]@].'\n*/\nexport function replaceUnescaped(expression, needle, replacement, context) {\n  const re = new RegExp(String.raw`${needle}|(?<$skip>\\[\\^?|\\\\?.)`, 'gsu');\n  const negated = [false];\n  let numCharClassesOpen = 0;\n  let result = '';\n  for (const match of expression.matchAll(re)) {\n    const {0: m, groups: {$skip}} = match;\n    if (!$skip && (!context || (context === Context.DEFAULT) === !numCharClassesOpen)) {\n      if (replacement instanceof Function) {\n        result += replacement(match, {\n          context: numCharClassesOpen ? Context.CHAR_CLASS : Context.DEFAULT,\n          negated: negated[negated.length - 1],\n        });\n      } else {\n        result += replacement;\n      }\n      continue;\n    }\n    if (m[0] === '[') {\n      numCharClassesOpen++;\n      negated.push(m[1] === '^');\n    } else if (m === ']' && numCharClassesOpen) {\n      numCharClassesOpen--;\n      negated.pop();\n    }\n    result += m;\n  }\n  return result;\n}\n\n/**\nRuns a callback for each unescaped instance of a regex pattern in the given context.\n\nDoesn't skip over complete multicharacter tokens (only `\\` plus its folowing char) so must be used\nwith knowledge of what's safe to do given regex syntax. Assumes UnicodeSets-mode syntax.\n@param {string} expression Search target\n@param {string} needle Search as a regex pattern, with flags `su` applied\n@param {(match: RegExpExecArray, details: {\n  context: 'DEFAULT' | 'CHAR_CLASS';\n  negated: boolean;\n}) => void} callback\n@param {'DEFAULT' | 'CHAR_CLASS'} [context] All contexts if not specified\n*/\nexport function forEachUnescaped(expression, needle, callback, context) {\n  // Do this the easy way\n  replaceUnescaped(expression, needle, callback, context);\n}\n\n/**\nReturns a match object for the first unescaped instance of a regex pattern in the given context, or\n`null`.\n\nDoesn't skip over complete multicharacter tokens (only `\\` plus its folowing char) so must be used\nwith knowledge of what's safe to do given regex syntax. Assumes UnicodeSets-mode syntax.\n@param {string} expression Search target\n@param {string} needle Search as a regex pattern, with flags `su` applied\n@param {number} [pos] Offset to start the search\n@param {'DEFAULT' | 'CHAR_CLASS'} [context] All contexts if not specified\n@returns {RegExpExecArray | null}\n*/\nexport function execUnescaped(expression, needle, pos = 0, context) {\n  // Quick partial test; avoid the loop if not needed\n  if (!(new RegExp(needle, 'su').test(expression))) {\n    return null;\n  }\n  const re = new RegExp(`${needle}|(?<$skip>\\\\\\\\?.)`, 'gsu');\n  re.lastIndex = pos;\n  let numCharClassesOpen = 0;\n  let match;\n  while (match = re.exec(expression)) {\n    const {0: m, groups: {$skip}} = match;\n    if (!$skip && (!context || (context === Context.DEFAULT) === !numCharClassesOpen)) {\n      return match;\n    }\n    if (m === '[') {\n      numCharClassesOpen++;\n    } else if (m === ']' && numCharClassesOpen) {\n      numCharClassesOpen--;\n    }\n    // Avoid an infinite loop on zero-length matches\n    if (re.lastIndex == match.index) {\n      re.lastIndex++;\n    }\n  }\n  return null;\n}\n\n/**\nChecks whether an unescaped instance of a regex pattern appears in the given context.\n\nDoesn't skip over complete multicharacter tokens (only `\\` plus its folowing char) so must be used\nwith knowledge of what's safe to do given regex syntax. Assumes UnicodeSets-mode syntax.\n@param {string} expression Search target\n@param {string} needle Search as a regex pattern, with flags `su` applied\n@param {'DEFAULT' | 'CHAR_CLASS'} [context] All contexts if not specified\n@returns {boolean} Whether the pattern was found\n*/\nexport function hasUnescaped(expression, needle, context) {\n  // Do this the easy way\n  return !!execUnescaped(expression, needle, 0, context);\n}\n\n/**\nExtracts the full contents of a group (subpattern) from the given expression, accounting for\nescaped characters, nested groups, and character classes. The group is identified by the position\nwhere its contents start (the string index just after the group's opening delimiter). Returns the\nrest of the string if the group is unclosed.\n\nAssumes UnicodeSets-mode syntax.\n@param {string} expression Search target\n@param {number} contentsStartPos\n@returns {string}\n*/\nexport function getGroupContents(expression, contentsStartPos) {\n  const token = /\\\\?./gsu;\n  token.lastIndex = contentsStartPos;\n  let contentsEndPos = expression.length;\n  let numCharClassesOpen = 0;\n  // Starting search within an open group, after the group's opening\n  let numGroupsOpen = 1;\n  let match;\n  while (match = token.exec(expression)) {\n    const [m] = match;\n    if (m === '[') {\n      numCharClassesOpen++;\n    } else if (!numCharClassesOpen) {\n      if (m === '(') {\n        numGroupsOpen++;\n      } else if (m === ')') {\n        numGroupsOpen--;\n        if (!numGroupsOpen) {\n          contentsEndPos = match.index;\n          break;\n        }\n      }\n    } else if (m === ']') {\n      numCharClassesOpen--;\n    }\n  }\n  return expression.slice(contentsStartPos, contentsEndPos);\n}\n"],
  "mappings": "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",
  "names": ["src_exports", "__export", "recursion", "Context", "replaceUnescaped", "expression", "needle", "replacement", "context", "re", "negated", "numCharClassesOpen", "result", "match", "m", "$skip", "forEachUnescaped", "callback", "execUnescaped", "pos", "hasUnescaped", "getGroupContents", "contentsStartPos", "token", "contentsEndPos", "numGroupsOpen", "r", "gRToken", "recursiveToken", "namedCapturingDelim", "token", "overlappingRecursionMsg", "emulationGroupMarker", "recursion", "expression", "data", "hasUnescaped", "Context", "useEmulationGroups", "hasNumberedBackref", "groupContentsStartPos", "openGroups", "hasRecursed", "numCharClassesOpen", "numCaptures", "match", "m", "captureName", "rDepth", "gRNameOrNum", "gRDepth", "assertMaxInBounds", "pre", "post", "makeRecursive", "isWithinReffedGroup", "g", "startPos", "groupContents", "getGroupContents", "groupContentsPre", "groupContentsPost", "expansion", "isUnnamedCapture", "max", "errMsg", "maxDepth", "isSubpattern", "namesInRecursed", "forEachUnescaped", "reps", "repeatWithDepth", "direction", "depthNum", "result", "captureNum", "replaceUnescaped", "backref", "suffix"]
}
