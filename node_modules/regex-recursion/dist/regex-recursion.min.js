var Regex;(Regex||={}).plugins=(()=>{var A=Object.defineProperty;var P=Object.getOwnPropertyDescriptor;var _=Object.getOwnPropertyNames;var H=Object.prototype.hasOwnProperty;var B=(e,t)=>{for(var r in t)A(e,r,{get:t[r],enumerable:!0})},j=(e,t,r,o)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of _(t))!H.call(e,n)&&n!==r&&A(e,n,{get:()=>t[n],enumerable:!(o=P(t,n))||o.enumerable});return e};var z=e=>j(A({},"__esModule",{value:!0}),e);var K={};B(K,{recursion:()=>J});var f=Object.freeze({DEFAULT:"DEFAULT",CHAR_CLASS:"CHAR_CLASS"});function x(e,t,r,o){let n=new RegExp(String.raw`${t}|(?<$skip>\[\^?|\\?.)`,"gsu"),s=[!1],u=0,c="";for(let i of e.matchAll(n)){let{0:l,groups:{$skip:a}}=i;if(!a&&(!o||o===f.DEFAULT==!u)){r instanceof Function?c+=r(i,{context:u?f.CHAR_CLASS:f.DEFAULT,negated:s[s.length-1]}):c+=r;continue}l[0]==="["?(u++,s.push(l[1]==="^")):l==="]"&&u&&(u--,s.pop()),c+=l}return c}function I(e,t,r,o){x(e,t,r,o)}function q(e,t,r=0,o){if(!new RegExp(t,"su").test(e))return null;let n=new RegExp(`${t}|(?<$skip>\\\\?.)`,"gsu");n.lastIndex=r;let s=0,u;for(;u=n.exec(e);){let{0:c,groups:{$skip:i}}=u;if(!i&&(!o||o===f.DEFAULT==!s))return u;c==="["?s++:c==="]"&&s&&s--,n.lastIndex==u.index&&n.lastIndex++}return null}function C(e,t,r){return!!q(e,t,0,r)}function T(e,t){let r=/\\?./gsu;r.lastIndex=t;let o=e.length,n=0,s=1,u;for(;u=r.exec(e);){let[c]=u;if(c==="[")n++;else if(n)c==="]"&&n--;else if(c==="(")s++;else if(c===")"&&(s--,!s)){o=u.index;break}}return e.slice(t,o)}var h=String.raw,y=h`\\g<(?<gRNameOrNum>[^>&]+)&R=(?<gRDepth>[^>]+)>`,b=h`\(\?R=(?<rDepth>[^\)]+)\)|${y}`,R=h`\(\?<(?![=!])(?<captureName>[^>]+)>`,$=new RegExp(h`${R}|${b}|\(\?|\\?.`,"gsu"),N="Cannot use multiple overlapping recursions",S="$E$";function J(e,t){if(!new RegExp(b,"su").test(e))return e;if(C(e,h`\(\?\(DEFINE\)`,f.DEFAULT))throw new Error("DEFINE groups cannot be used with recursion");let r=!!t?.useEmulationGroups,o=C(e,h`\\[1-9]`,f.DEFAULT),n=new Map,s=[],u=!1,c=0,i=0,l;for($.lastIndex=0;l=$.exec(e);){let{0:a,groups:{captureName:m,rDepth:g,gRNameOrNum:p,gRDepth:D}}=l;if(a==="[")c++;else if(c)a==="]"&&c--;else if(g){if(O(g),u)throw new Error(N);if(o)throw new Error("Numbered backrefs cannot be used with global recursion");let d=e.slice(0,l.index),w=e.slice($.lastIndex);if(C(w,b,f.DEFAULT))throw new Error(N);return G(d,w,+g,!1,r)}else if(p){O(D);let d=!1;for(let E of s)if(E.name===p||E.num===+p){if(d=!0,E.hasRecursedWithin)throw new Error(N);break}if(!d)throw new Error(h`Recursive \g cannot be used outside the referenced group "\g<${p}&R=${D}>"`);let w=n.get(p),U=T(e,w);if(o&&C(U,h`${R}|\((?!\?)`,f.DEFAULT))throw new Error("Numbered backrefs cannot be used with recursion of capturing groups");let k=e.slice(w,l.index),F=U.slice(k.length+a.length),L=G(k,F,+D,!0,r),v=e.slice(0,w),W=e.slice(w+U.length);e=`${v}${L}${W}`,$.lastIndex+=L.length-a.length-k.length-F.length,s.forEach(E=>E.hasRecursedWithin=!0),u=!0}else if(m)i++,n.set(String(i),$.lastIndex),n.set(m,$.lastIndex),s.push({num:i,name:m});else if(a.startsWith("(")){let d=a==="(";d&&(i++,n.set(String(i),$.lastIndex)),s.push(d?{num:i}:{})}else a===")"&&s.pop()}return e}function O(e){let t=`Max depth must be integer between 2 and 100; used ${e}`;if(!/^[1-9]\d*$/.test(e))throw new Error(t);if(e=+e,e<2||e>100)throw new Error(t)}function G(e,t,r,o,n){let s=new Set;o&&I(e+t,R,({groups:{captureName:c}})=>{s.add(c)},f.DEFAULT);let u=r-1;return`${e}${M(`(?:${e}`,u,o?s:null,"forward",n)}(?:)${M(`${t})`,u,o?s:null,"backward",n)}${t}`}function M(e,t,r,o,n){let u=i=>o==="backward"?t-i+2-1:i+2,c="";for(let i=0;i<t;i++){let l=u(i);c+=x(e,h`${R}|\\k<(?<backref>[^>]+)>${n?h`|\((?!\?)`:""}`,({0:a,groups:{captureName:m,backref:g}})=>{if(g&&r&&!r.has(g))return a;if(a==="(")return`(${S}`;let p=`_$${l}`;return m?`(?<${m}${p}>${n?S:""}`:h`\k<${g}${p}>`},f.DEFAULT)}return c}return z(K);})();
//# sourceMappingURL=regex-recursion.min.js.map
