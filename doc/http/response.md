# Resposta

A instÃ¢ncia da classe de resposta permite que vocÃª responda Ã s solicitaÃ§Ãµes HTTP. O AdonisJS pronto para uso oferece suporte ao envio de 
fragmentos HTML, objetos JSON, streams e muito mais.

VocÃª pode acessar o objeto `response` da instÃ¢ncia de contexto HTTP passada para o manipulador de rota, middleware e manipulador de exceÃ§Ã£o.

```ts
Route.get('/', (ctx) => {
  ctx.response.send('hello world')
})
```

### Enviando uma resposta
A maneira mais simples de enviar uma resposta Ã© retornar um valor do manipulador de rota.

```ts
Route.get('/', () => {
  /** Texto simples */
  return 'This is the homepage'

  /** Fragmento HTML */
  return '<p> This is the homepage </p>'

  /** Resposta em JSON */
  return { page: 'home' }

  /** Converte ISO para string */
  return new Date()
})
```

AlÃ©m de retornar um valor, vocÃª tambÃ©m pode usar o mÃ©todo `response.send` para enviar a resposta. O primeiro argumento Ã© 
o corpo da resposta (igual ao valor de retorno). Opcionalmente, vocÃª pode passar um segundo argumento para gerar e definir o `etag`.

> VocÃª tambÃ©m pode habilitar a geraÃ§Ã£o de `ETag` para todas as 
> respostas habilitando a propriedade `http.etag` dentro do arquivo `config/app.ts`.

```ts
response.send({ hello: 'world' })

// Com etag
response.send({ hello: 'world' }, true)
```

#### Serializando o corpo da resposta
A seguir estÃ¡ a lista de tipos de dados serializados pela classe de resposta.

* Matrizes e objetos sÃ£o sequenciados usando a funÃ§Ã£o [stringify segura](https://github.com/poppinss/utils/blob/develop/src/safeStringify.ts). 
  O mÃ©todo Ã© semelhante Ã  `JSON.stringify`, mas remove as referÃªncias circulares.
* O nÃºmero e os valores booleanos sÃ£o convertidos em uma string.
* A instÃ¢ncia de Date Ã© convertida em uma string chamando o mÃ©todo `toISOString`.
* ExpressÃµes regulares e objetos de erro sÃ£o convertidos em uma string chamando o mÃ©todo `toString` neles.
* Qualquer outro tipo de dados resulta em uma exceÃ§Ã£o.

#### InferÃªncia de tipo de conteÃºdo
A classe de resposta define automaticamente os cabeÃ§alhos `content-type` e `content-length` inspecionando o corpo da resposta.

> O cabeÃ§alho automÃ¡tico do tipo de conteÃºdo Ã© definido apenas quando vocÃª nÃ£o o define explicitamente durante o ciclo de vida da solicitaÃ§Ã£o.

* O tipo de conteÃºdo Ã© definido como `application/json` para matrizes e objetos.
* Ã‰ definido como `text/html` para fragmentos HTML.
* As respostas JSONP sÃ£o enviadas com o tipo de conteÃºdo `text/javascript`.
* Para todo o resto, definimos o tipo de conteÃºdo como `text/plain`.

### Resposta preguiÃ§osa
Muitos frameworks Node.js escrevem a resposta para o fluxo de saÃ­da assim que vocÃª chama o mÃ©todo `response.send`. AdonisJS nÃ£o faz o mesmo. 
Em vez disso, esperamos que o manipulador de rota e todas as chamadas de middleware terminem antes de escrever a resposta final.

Essa abordagem garante que a Ãºltima chamada para `response.send` sempre venÃ§a. Na maioria dos casos, esse comportamento nÃ£o afeta vocÃª 
ou seus aplicativos. No entanto, ele permite pÃ³s-processar a resposta dentro de um middleware.

A seguir estÃ¡ um exemplo de conversÃ£o das chaves `camelCase` do objeto em `snake_case`.

O exemplo a seguir nÃ£o Ã© a melhor maneira de transformar a resposta. Ã‰ apenas uma demonstraÃ§Ã£o 
de como Ã© o pÃ³s-processamento de uma resposta

```ts
import snakeCaseKeys from 'snakecase-keys'

Route
  .get('/', async ({ response }) => {
    response.send({ fullName: 'Harminder Virk' })
  })
  .middleware(async ({ response }, next) => {
    await next()

    /**
     * O cÃ³digo a seguir Ã© executado apÃ³s o manipulador de rota.
     * Leia a documentaÃ§Ã£o sobre middlewares para saber como funciona
     */
    const existingBody = response.lazyBody[0]
    if (!existingBody || existingBody.constructor !== Object) {
      return
    }

    response.send(snakeCaseKeys(existingBody))
  })
```

No exemplo acima, o manipulador de rota escreve o corpo da resposta usando o mÃ©todo `response.send`. No entanto, o middleware 
downstream transforma o corpo e o reescreve usando novamente `response.send`.

Como o corpo da resposta Ã© avaliado vagarosamente, sempre definiremos o comprimento do conteÃºdo e os cabeÃ§alhos de tipo de 
conteÃºdo inspecionando o corpo de resposta mais recente.

### Status de resposta e cabeÃ§alhos
A seguir estÃ£o os mÃ©todos para trabalhar com os cabeÃ§alhos de resposta e o status da resposta.

#### header
O mÃ©todo `response.header` define o cabeÃ§alho da resposta HTTP. Usar este mÃ©todo substitui o cabeÃ§alho existente (se houver).

```ts
response.header('Content-type', 'text/html')
```

#### append
O mÃ©todo `response.append` Ã© semelhante ao mÃ©todo `header`. No entanto, ele Ã© anexado ao valor do cabeÃ§alho existente (se houver).

```ts
response.append('Set-cookie', 'cookie-value')
```

#### removeHeader
O cabeÃ§alho `response.removeHeader` permite remover um cabeÃ§alho de resposta existente.

```ts
response.removeHeader('Content-type')
```

#### getHeader
O mÃ©todo `response.getHeader` retorna o valor de um cabeÃ§alho existente.

```ts
const cookie = response.getHeader('Set-cookie')
```
 
#### safeHeader
O mÃ©todo `response.safeHeader` Ã© semelhante ao mÃ©todo `header`. No entanto, ele apenas define o cabeÃ§alho se ainda nÃ£o estiver definido.

```ts
response.safeHeader('Content-type', 'application/json')
```

#### status
O mÃ©todo `response.status` define o status da resposta HTTP. VocÃª tambÃ©m pode usar os mÃ©todos descritivos para 
definir o status e o corpo da resposta juntos.

```ts
response.status(401)
```

#### safeStatus
Assim como o mÃ©todo `status`, o `response.safeStatus` define o status se ainda nÃ£o estiver definido.

```ts
response.safeStatus(401)
```

### Streams e downloads de arquivos
AdonisJS tem suporte de primeira classe para fluxos de streams e downloads de arquivos. AlÃ©m disso, garantimos a 
limpeza adequada dos fluxos em caso de erros.

#### Stream
O mÃ©todo `response.stream` permite canalizar o fluxo para a resposta. Este mÃ©todo nÃ£o define o tipo de conteÃºdo e os cabeÃ§alhos de 
comprimento do conteÃºdo, vocÃª terÃ¡ que defini-los manualmente.

```ts
const image = fs.createReadStream('./some-file.jpg')
response.stream(image)
```

Em caso de erros, uma resposta 500 Ã© enviada ao cliente. No entanto, vocÃª pode enviar uma mensagem e um cÃ³digo de status personalizado, 
definindo um `callback` como o segundo parÃ¢metro.

```ts
response.stream(image, (error) => {
  return ['Unable to send file', 400]
})
```

#### download
O mÃ©todo `download` transmite o arquivo para o cliente lendo-o do disco. Ao contrÃ¡rio do mÃ©todo de fluxo, o mÃ©todo `download` define o 
tipo de conteÃºdo e os cabeÃ§alhos de comprimento do conteÃºdo.

```ts
const filePath = Application.tmpPath('uploads/some-file.jpg')
response.download(filePath)
```

Opcionalmente, vocÃª tambÃ©m pode definir a `ETag` para o arquivo.

```ts
const filePath = Application.tmpPath('uploads/some-file.jpg')
response.download(filePath, true)
```

Um cÃ³digo de status personalizado e uma mensagem podem ser definidos passando a como `callback` no terceiro parÃ¢metro.

```ts
const filePath = Application.tmpPath('uploads/some-file.jpg')

response.download(filePath, true, (error) => {
  if (error.code === 'ENOENT') {
    return ['File does not exists', 404]
  }

  return ['Cannot download file', 400]
})
```

##### attachment
O `response.attachment` Ã© semelhante ao mÃ©todo `download`. No entanto, permite personalizar o nome do arquivo baixado e tambÃ©m define o 
cabeÃ§alho `Content-Disposition`.

```ts
const filePath = Application.tmpPath('uploads/some-file.jpg')
response.attachment(filePath)

// Define um nome customizado
response.attachment(filePath, 'foo.jpg')

// Customiza a disposiÃ§Ã£o do arquivo
response.attachment(filePath, 'foo.jpg', 'inline')
```

### Redirecionamento
A classe de resposta expÃµe uma API rica para trabalhar com redirecionamentos, incluindo redirecionar usuÃ¡rios para uma rota, 
redirecionar de volta para a pÃ¡gina anterior e encaminhar a string de consulta existente.

VocÃª pode obter uma instÃ¢ncia da classe [Redirect](https://github.com/adonisjs/http-server/blob/develop/src/Redirect/index.ts) 
usando o mÃ©todo `response.redirect()`.

```ts
// Redireciona de volta
response.redirect().back()

// Redireciona para uma URL
response.redirect().toPath('/some/url')
```

#### CÃ³digo de status personalizado
Por padrÃ£o, um cÃ³digo `302` de status Ã© usado. VocÃª pode substituÃ­-lo usando o mÃ©todo `.status`.

```ts
response.redirect().status(301).toPath('/some/url')
```

#### Redirecionar para uma rota
VocÃª tambÃ©m pode redirecionar a solicitaÃ§Ã£o para uma rota nomeada usando o mÃ©todo `.toRoute`.

```ts
response.redirect().toRoute('PostsController.show', { id: 1 })
```

#### Definir/encaminhar strings de consulta
O mÃ©todo `.withQs` permite que vocÃª encaminhe a string de consulta existente ou defina uma string de 
consulta personalizada durante o redirecionamento.

```ts
response
  .redirect()
  .withQs() // ğŸ‘ˆ encaminha com o qs existente
  .back()

response
  .redirect()
  .withQs({ sort: 'id' }) // ğŸ‘ˆ customizado
  .back()
```

### `withQs` com parÃ¢metros
Chamar o mÃ©todo `.withQs` com o objeto personalizado vÃ¡rias vezes mescla os objetos. No entanto, vocÃª pode combinÃ¡-lo com o mÃ©todo 
`.clearQs` para limpar os objetos existentes. Por exemplo:

```ts
response
  .redirect()
  .withQs({ sort: 'id' })
  .clearQs()
  .withQs({ filters: { name: 'virk' } })
  .toPath('/users')

// URL: /users?filters[name]=virk
```

#### `withQs` sem parÃ¢metros
Chamar o mÃ©todo `withQs` sem nenhum parÃ¢metro encaminharÃ¡ a string de consulta existente para a URL redirecionada. Se vocÃª redirecionar 
o usuÃ¡rio de volta Ã  pÃ¡gina antiga, a string de consulta da URL referenciada do cabeÃ§alho serÃ¡ usada.

```ts
response.redirect().withQs().back() // ğŸ‘ˆ cabeÃ§alho de referÃªncia que a qs Ã© usada
```

```ts
response.redirect().withQs().toPath('/users') // ğŸ‘ˆ Usando QS da URL atual
```

### Abortar e responder
A classe de resposta permite que vocÃª aborte a solicitaÃ§Ã£o HTTP atual usando os mÃ©todos `response.abort` ou `response.abortIf`.

#### abortar
O mÃ©todo `response.abort` aborta a solicitaÃ§Ã£o atual levantando uma [`AbortException`](https://github.com/adonisjs/http-server/blob/develop/src/Response/index.ts#L44)

O mÃ©todo aceita um total de dois argumentos: ou seja, o corpo da resposta e um status opcional.

```ts
if (!auth.user) {
  response.abort('Not authenticated')

  // Com status customizado
  response.abort('Not authenticated', 401)
}

#### abortIf
O mÃ©todo `response.abortIf` aceita uma condiÃ§Ã£o e aborta a solicitaÃ§Ã£o quando a condiÃ§Ã£o Ã© verdadeira.

```ts
response.abortIf(!auth.user, 'Not authenticated', 401)
```

#### abortUnless
O mÃ©todo `response.abortUnless` Ã© o oposto do mÃ©todo abortIf.

```ts
response.abortUnless(auth.user, 'Not authenticated', 401)
```

### Outros mÃ©todos e propriedades
A seguir estÃ¡ a lista de outros mÃ©todos e propriedades disponÃ­veis na classe de resposta.

#### finished
Descubra se a resposta foi gravada no fluxo de saÃ­da.

```ts
if (!response.finished) {
  response.send()
}
```
#### headersSent
Um alias para a propriedade `res.headersSent` do Node.js.

#### isPending
Esta propriedade Ã© o oposto da propriedade `response.finished`.

```ts
if (response.isPending) {
  response.send()
}
```

#### vary
Um atalho para definir o [cabeÃ§alho de variaÃ§Ã£o HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Vary). 
Chamar o mÃ©todo `vary` vÃ¡rias vezes acrescentarÃ¡ Ã  lista de cabeÃ§alhos existentes.

```ts
response.vary('Origin')

// Define mÃºltiplos cabeÃ§alhos
response.vary('Accept, User-Agent')
```

#### location
Um atalho para definir o [cabeÃ§alho do local HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Location).

```ts
response.location('/dashboard')
```

#### type
Um atalho para definir o cabeÃ§alho do [tipo de conteÃºdo HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type).

```ts
response.type('application/json')
```

VocÃª tambÃ©m pode usar as palavras-chave para definir o tipo de conteÃºdo. Por exemplo:

```ts
response.type('json') // define como content-type=application/json
response.type('html') // define como content-type=text/html
```

#### MÃ©todos de resposta descritiva
A classe de resposta tem vÃ¡rios mÃ©todos descritivos (um de cada status HTTP) para enviar o corpo da resposta e 
definir o status ao mesmo tempo. Por exemplo:

```ts
response.badRequest({ error: 'Invalid login credentials' })
response.forbidden({ error: 'Unauthorized' })
response.created({ data: user })
```

[Aqui](https://github.com/adonisjs/http-server/blob/ea55c2a65fd388373d0b4e35ae45bee9cb096d02/src/Response/index.ts#L937-L1145) estÃ¡ a lista de todos os mÃ©todos disponÃ­veis.

### Estendendo classe de resposta
VocÃª pode estender a classe Response usando macros ou getters. O melhor lugar para estender a resposta Ã© dentro de um 
provedor de serviÃ§os personalizado.

Abra o arquivo `providers/AppProvider.ts` prÃ©-existente e escreva o cÃ³digo a seguir dentro do mÃ©todo `boot`.

```ts
import { ApplicationContract } from '@ioc:Adonis/Core/Application'

export default class AppProvider {
  public static needsApplication = true
  constructor(protected app: ApplicationContract) {}

  public async boot() {
    const Response = this.app.container.use('Adonis/Core/Response')

    Response.macro('flash', function (messages) {
      this.ctx!.session.flash(messages)
      return this
    })
  }
}
```

No exemplo acima, adicionamos o mÃ©todo `flash` Ã  classe de resposta. Ele define as mensagens flash chamando o mÃ©todo `session.flash` internamente.

VocÃª pode usar o mÃ©todo recÃ©m-adicionado da seguinte maneira.

```ts
Route.post('users', ({ response }) => {
  response.flash({ success: 'User created' })
})
```

#### Informar ao typescript sobre o mÃ©todo
A propriedade `flash` Ã© adicionada no tempo de execuÃ§Ã£o e, portanto, o TypeScript nÃ£o a conhece. Para informar ao TypeScript, 
usaremos a fusÃ£o de declaraÃ§Ãµes e adicionaremos uma propriedade de interface Ã  `ResponseContract`.

Crie um novo arquivo no caminho `contracts/response.ts` (o nome do arquivo nÃ£o Ã© importante) e cole o seguinte conteÃºdo dentro dele.

```ts
declare module '@ioc:Adonis/Core/Response' {
  interface ResponseContract {
    flash(messages: any): this
  }
}
```
